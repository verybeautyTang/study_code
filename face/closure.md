一般了解作用域都要熟悉一下基本知识
1、作用域
  全局作用域
  函数作用域
【代码看例子1】
简单总结一下：js在执行某个函数的时候，如果遇见变量需要读取数据的情况，会根据就近原则在当前作用域下去查找该变量，如果在该作用域内没有找到的话，就要跳出当前作用域去到上层作用域中查找。

随着作用域概念的不断更新，在ES6中新增了let、const声明变量的块级作用域，
 块级作用域：在作用域限制范围在代码块里。
 暂时性死区：在相应花括号形成的作用域中存在一个死区，起始于函数开始，终止于相关变量声明语句所在行。在这个死区内无法使用let、const声明的变量【函数参数的默认数据设置也会影响】

 2、执行上下文和调用栈【代码看例子2】
 执行上下文：当前代码的执行环境/作用域【执行上下文包含了作用域链，有了作用域链，才会有执行上下文的一部分。【this + 作用域链 + 变量对象 = 执行上下文】
    代码执行的两个阶段
        代码预编译阶段：前置阶段，会将js编译成可执行的代码【在词法分析、语法分析都执行完毕之后，就会开始预编译阶段】
          对代码的内存空间进行分配
          进行变量声明
          进行变量提升，值设置为undefined
          对非表达式的函数进行变量提升【就是直接声明为function类型的函数进行变量提升】
        代码执行阶段：执行代码逻辑，执行上下文会在这个阶段全部完成
    代码执行过程
    1、预编译创建变量对象 
    2、代码执行，确定作用域链。
函数在执行时，相关的函数可以访问函数体内的变量，该变量会在预编译阶段被创建，在执行阶段被激活，在函数执行完毕之后，函数会被销毁。局部变量会被垃圾回收。


闭包：
  概念： 在函数嵌套函数的时候，内层函数使用了外层函数的变量并且全局作用域可以访问到内层函数，进而形成闭包。外界可以通过返回的内层函数获取到外层函数的变量值【代码看例子3】
  应用： 隐藏数据、或者缓存一些不被更改的数据
  优点：可以通过闭包实现模块化。
  缺点：垃圾回收机制不生效，引起内存泄漏
    内存管理：一般基本类型都是在栈里面管理【number、string、boolean、bigint、symbol、null、undefined】，占有固定的内存大小，引用类型存放在堆里面，内存 空间打大小并不固定。
    内存泄漏：内存空间并没有引用，但是由于某些原因并没有被释放。内存泄漏的风险很大，会导致程序运行变慢甚至崩溃。
      防止内存泄漏
        不需要的变量及时设置为null
        在移除元素的时候把相对应地事件移除
    垃圾回收机制
      标记清除
      引用计数
    
    
    
 